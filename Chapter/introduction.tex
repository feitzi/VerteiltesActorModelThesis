\chapter{Einleitung}\label{cha:introduction}
\section{Motivation}\label{sec:introduction:motivation}
Die Konzeption und Umsetzung von modernen Applikationen welche eine vielzahl an Anfragen gleichzeitig verarbeiten müssen, stellt Entwickler seit jeher vor große Herausforderungen. Einerseits muss, in häufigen Fällen äußerst komplexe, Geschäftsprozesse und Geschäftsumfelder beachtet werden, und andererseits muss die technische Komplexität bewerkstelligt werden. In \cite{Vernon2015ReactiveAkka} und \cite{Evans2004Domain-drivenSoftware} wird bereits darüber diskutiert, dass der Einsatz von Datenbanksystemen, unterschiedliche Anwendungsapplikationen mit verschiedensten Frameworks und Aufgabengebiete sowie die Verteilung, teils über verschiedene Kontinente, dieser Komponenten, Softwarearchitekten immer wieder vor ihre Grenzen stoßen lässt. \\
Weiters ist die Parallelisierung von Anwendungen immer wichtiger. Denn das lange Zeit gültige Gesetz von Moor, siehe dazu \cite{moore1965moore}, welches den stetige Anstieg an Prozessorleistung garantiert, ist aufgrund von physikalischen und wirtschaftlichen Limitierungen praktisch nicht mehr gültig \citep{mann2000end}. Deshalb steigt in modernen, finanziell vertretbaren, Prozessoren die Taktfrequenz nur mehr gering. Stattdessen werden Prozessoren mit immer mehr Kernen ausgestattet womit parallelisierte Anwendungen möglich werden und somit auch die Verarbeitungszeit für, dementsprechend Entwickelte, Operationen sinkt. Parallelisierte Anwendungen zu erstellen, erhöht jedoch die, wie bereits erwähnt, komplexität heutiger Anwendungen noch mehr. \\
Das von Carl Hewitt entwickelte \textit{Actor-Model}, siehe \cite{Hewitt1973AIntelligence}, löst das Problem mit der parallelisierung auf eine äußert effiziente Art, ohne dabei die Komplexität des Quellcodes zu erhöhen. Auch für die Verteilung von Systemen über mehrere Standorte hinweg lässt sich das Model gut verwenden. \\
Nachdem das \textit{Actor-Model} seiner Zeit ihm Jahr 1973 vorraus war, gab es lange keine praktischen Anwendungen welche mit dem \textit{Actor-Model} umgesetzt wurden, und es konnte sich, bis vor kurzem, kaum verbreiten \citep{mackay1997has}. Durch die Bedürfnisse an parallelisierten und verteilten Systemen konnte sich das \textit{Actor-Model} in den letzten Jahren durch verschiedene Projekte wie \textit{Akka}, \textit{Scala} oder andere, siehe dazu Kapitel \ref{sec:ActorFrameworks}, wieder an popularität gewinnen.

\section{Ziel der Arbeit}\label{sec:introduction:workGoal}
Um eine Software auf Basis des \textit{Actor-Models} zu entwickeln, braucht es zuerst eine tieferes Verständnis für das \textit{Actor-Model}  selbst.  Neben dem Zusammentragen  von gängiger Fachliteratur über das \textit{Actor-Model} soll sich die Arbeit auch mit der praktischen Implementierung des Softwaremodels beschäftigen. Ein Schwerpunkt dieser Recherche wird sich auf die Schwierigkeiten und die dazugehörigen Lösungsvorschläge des verteilten \textit{Actor-Models}  legen. \\
Eine transaktionsbasierte Applikation benötigt möglichkeiten Daten zu speichern. Wie beispielsweise in \cite{Vernon2015ReactiveAkka} beschrieben, bietet sich für die Persistierung eines Actors das \textit{Event-Sourcing} sowie die {Command Query Responsibility Segregation (CQRS)} an. Diese alternative Herangehensweise für die langfristige Speicherung von Daten gegenüber dem geläufigen Normalisieren und Persistieren in relationalen Datenbanksystemen ist aus der Domain-Driven-Design Software Philosophie (\cite{Evans2004Domain-drivenSoftware}) heraus  entstanden. Da das \textit{Actor-Model} laut \cite{Vernon2015ReactiveAkka} mit dem {Domain-Driven-Design} (DDD) von \citep{Evans2004Domain-drivenSoftware} gut zusammenspielt, wird sich diese Arbeit weiters mit der Zusammenführung von DDD und dem \textit{Actor-Model}  befassen um ein verteiltes und transaktionales Softwaresystem zu entwerfen. \\
Um die theoretische Erkenntnisse über das \textit{Actor-Model}  und deren Lösungsmodelle für die Verteilung im praktischen Umfeld zu erproben, ist es Teil dieser Arbeit eine Software zu entwerfen und zu implementieren. Diese zu entwickelnde Applikation soll die im dem theoretischen Teil erarbeiteten Problemfelder in einem praktischen Beispiel aufzeigen. \\
Um eine solche Software zu schreiben, ist es notwendig, auf Basis des theoretischen Teils, Anforderungen an die Software zu stellen und anhand dieser die Softwarearchitektur aufzubauen und umzusetzen. 

\subsection{Forschungsfrage}\label{sec:introduction:forschungsfrage}
Die Entwicklung moderner Anwendungen, ist wie bereits in der Motivation \ref{sec:introduction:motivation} beschrieben, nicht trivial und erfordert wissen in unterschiedlichesten Bereichen. Im Rahmen der vorliegenden Arbeit, soll die Fragestellung \ref{theorem:forschungsfrage} ausgearbeitet werden und auf Probleme sowie Lösungsansätze bei der Entwicklung von verteilter Softwarearchitekten eingegangen werden.
\begin{Theorem}
\label{theorem:forschungsfrage}
Wie lässt sich eine Softwarearchitektur für ein verteiltes Transaktionssystem mit der Hilfe des \textit{Actor-Models} realisieren? Welche Probleme entstehen dabei und wie sehen Lösungsansätze dafür aus?
\end{Theorem}

\section{Methodik}
Die Auseinandersetzung mit der Forschungsfrage \ref{theorem:forschungsfrage} erfolgt durch eine qualitative Literaturrecherche und eine darauf aufbauende, theoretische Auseinandersetzung mit den drei Aspekten der Forschungsfrage \textit{Actor-Model}, \textit{Verteile Systeme} und \textit{Transaktionssysteme}. Aus den Erkenntnissen der qualitativen Recherche, wird ein repräsentativer Anforderungskatalog für ein verteiltes, transaktionales System abgeleitet. Dieser Anforderungskatalog wird anschließend mit dem \textit{Actor-Model} in einem praktischen Beispiel umgesetzt. Die daraus resultierenden praktischen Lösungsansätze, werden abschließend beschrieben sowie diskutiert.
 
\section{Abgrenzung}
Wie bereits erwähnt erstreckt sich das Thema Actoren und transaktionalen und verteilten Systeme über einen großen und umfangreiches Wissensgebiet. Der Schwerpunkt der Arbeit liegt auf der \textit{Actor-Model} und die Möglichkeit mit diesem Softwaremodel eine verteilte Anwendung zu realisieren. Auf stark verknüpfte Themen wie das \textit{Domain Driven Design} Konzept aus \cite{Evans2004Domain-drivenSoftware}, oder verschiedene Datenbanksystemen wird zwar eingegangen aber nicht näher betrachtet. Auf verwante Themengebiete für verteilte Systeme wie beispielsweise Container Infrastruktur, Netzwerktechnik oder Betriebsysteme wird im Zuge dieser Arbeit nicht eingegangen, da diese Themengebiete aufgrund der Infrastrukturellen Sicht, nicht direkt eine Rolle, für die Beantwortung der Forschungsfrage, spielen. 

\section{Aufbau}
Die Arbeitet unterteilt sich in zwei Teile. Beginnend mit dem theoretische ersten Teile, wird mit dem Kapitel \fullref{actor:chapter} () auf das \textit{Actor-Model} eingegangen und diskutiert. Nachfolgend folgt das Kapitel \fullref{cha:distributedSystems}, welches sich mit den Problemen beschäftigt welche bei verteilten Systemen häufig anzutreffen sind. Der theoretische Teil der Arbeit wird mit dem Kapitel \fullref{cha:cha:transactionSystems} abgeschlossen, welcher bekannte Lösungsansätze für transaktionale Systeme diskutiert. \\
Der zweite Teil der Arbeit umfasst die praktische Auseinandersetzung mit der Forschungsfrage. Dabei wird in Kapitel \fullref{cha:Eruierung} der Anforderungskatalog basierend auf den in Teil eins erarbeiteten Informationen erstellt, und vorhandene Frameworks für die Umsetzung betrachtet. Auf die Umsetzung des Anforderungskataloges wird anschließend in Kapitel \fullref{cha:practicalDevelopment} eingegangen. Abschließend wird in Kapitel \fullref{cha:evaluation} der erarbeite Erkenntnisstand diskutiert und Bewertet.  