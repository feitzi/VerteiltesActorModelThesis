\chapter{Einleitung}\label{cha:introduction}
\section{Motivation}\label{sec:introduction:motivation}
Die Konzeption und Umsetzung von modernen Applikationen welche eine Vielzahl an Anfragen gleichzeitig verarbeiten müssen, stellt Entwickler seit jeher vor große Herausforderungen. Einerseits müssen, in häufigen Fällen äußerst komplexe, Geschäftsprozesse und Geschäftsumfelder beachtet werden, und andererseits sollte die technische Komplexität heutiger Systeme bewerkstelligt werden. In \cite{Vernon2015ReactiveAkka} und \cite{Evans2004Domain-drivenSoftware} wird bereits darüber diskutiert, dass der Einsatz von Datenbanksystemen zusammen mit unterschiedlichen Anwendungsapplikationen aufbauend auf diverse Frameworks  sowie die Verteilung der Applikation teils über verschiedene Kontinente,  Softwarearchitekten immer wieder vor ihre Grenzen stoßen lässt. \\
Weiters ist die Parallelisierung von Anwendungen immer wichtiger. Denn das lange Zeit gültige Gesetz von Moor, siehe dazu \cite{moore1965moore}, welches den stetige Anstieg an Prozessorleistung garantiert, ist aufgrund von physikalischen und wirtschaftlichen Limitierungen in der Praxis nicht mehr gültig \citep{mann2000end}. Deshalb steigt in modernen, finanziell vertretbaren, Prozessoren die Taktfrequenz nur mehr gering. Stattdessen werden Prozessoren mit immer mehr Kernen ausgestattet, womit parallelisierte Anwendungen möglich werden und somit auch die Verarbeitungszeit für, dementsprechend entwickelte Operationen, sinkt. Parallelisierte Anwendungen zu erstellen, erhöht jedoch die Komplexität heutiger Anwendungen noch mehr. \\
Das von Carl Hewitt entwickelte \textit{Actor-Model}, siehe \cite{Hewitt1973AIntelligence}, löst das Problem mit der Parallelisierung auf eine äußert effiziente Art, ohne dabei die Komplexität des Quellcodes wesentlich zu erhöhen. Auch für die Verteilung von Systemen über mehrere Standorte hinweg lässt sich das Model vermutlich gut verwenden. \\
Nachdem das \textit{Actor-Model} seiner Zeit ihm Jahr 1973 voraus war, gab es lange keine praktischen Anwendungen welche mit dem \textit{Actor-Model} umgesetzt wurden, und es konnte sich, bis vor kurzem, kaum verbreiten \citep{mackay1997has}. Durch die Bedürfnisse an parallelisierten und verteilten Systemen konnte sich das \textit{Actor-Model} in den letzten Jahren durch verschiedene Projekte wie \textit{Akka}, \textit{Scala} oder andere, siehe dazu Kapitel \ref{sec:ActorFrameworks}, wieder an Popularität gewinnen. 

\section{Ziel der Arbeit}\label{sec:introduction:workGoal}
Um eine Software auf Basis des \textit{Actor-Models} zu entwickeln, braucht es zuerst eine tieferes Verständnis für das \textit{Actor-Model}  selbst.  Neben dem Zusammentragen  von gängiger Fachliteratur über das \textit{Actor-Model} soll sich die Arbeit auch mit der praktischen Implementierung des Softwaremodels beschäftigen. Ein Schwerpunkt dieser Recherche wird sich auf die Schwierigkeiten und die dazugehörigen Lösungsvorschläge des verteilten \textit{Actor-Models}  legen. \\
Eine transaktionsbasierte Applikation benötigt Möglichkeiten Daten zu speichern. Wie beispielsweise in \cite{Vernon2015ReactiveAkka} beschrieben, bietet sich für die Persistierung eines Actors das \textit{Event-Sourcing} sowie die {Command Query Responsibility Segregation (CQRS)} an. Diese alternative Herangehensweise für die langfristige Speicherung von Daten, gegenüber dem geläufigen Normalisieren und Persistieren in relationalen Datenbanksystemen, ist aus der Domain-Driven-Design Software Philosophie (\cite{Evans2004Domain-drivenSoftware}) heraus  entstanden. Da das \textit{Actor-Model} laut \cite{Vernon2015ReactiveAkka} mit dem {Domain-Driven-Design} (DDD) von \citep{Evans2004Domain-drivenSoftware} gut zusammenspielt, wird sich die Arbeit weiters mit der Zusammenführung von DDD und dem \textit{Actor-Model}  befassen, um ein verteiltes und transaktionales Softwaresystem zu entwerfen. \\
Um die theoretische Erkenntnisse über das \textit{Actor-Model}  und deren Lösungsmodelle für die Verteilung im praktischen Umfeld zu erproben, ist es weiters Teil dieser Arbeit eine Software zu entwerfen und zu implementieren welche auf dem \textit{Actor-Model} aufbaut. Diese zu entwickelnde Applikation soll die im dem theoretischen Teil erarbeiteten Problemfelder in einem praktischen Beispiel aufzeigen. \\
Um eine solche Software zu schreiben, ist es notwendig, auf Basis des theoretischen Teils, Anforderungen an die Software zu erstellen und anhand dieser die Softwarearchitektur aufzubauen sowie umzusetzen. 

\subsection{Forschungsfrage}\label{sec:introduction:forschungsfrage}
Die Entwicklung moderner Anwendungen, ist wie bereits in der Motivation \ref{sec:introduction:motivation} beschrieben, nicht trivial und erfordert wissen in unterschiedlichsten Bereichen. Im Rahmen der vorliegenden Arbeit, soll die Fragestellung \ref{theorem:forschungsfrage} ausgearbeitet werden und auf Probleme sowie Lösungsansätze bei der Entwicklung von verteilter Softwarearchitekturen eingegangen werden.
\begin{Theorem}
\label{theorem:forschungsfrage}
Wie lässt sich eine Softwarearchitektur für ein verteiltes Transaktionssystem mit der Hilfe des \textit{Actor-Models} realisieren? Welche Probleme entstehen dabei und wie sehen Lösungsansätze dafür aus?
\end{Theorem}

\section{Methodik}
Die Auseinandersetzung mit der Forschungsfrage \ref{theorem:forschungsfrage} erfolgt durch eine qualitative Literaturrecherche und eine darauf aufbauende, theoretische Auseinandersetzung mit den drei Aspekten der Forschungsfrage \textit{Actor-Model}, \textit{Verteile Systeme} und \textit{Transaktionssysteme}. Aus den Erkenntnissen der qualitativen Recherche, wird ein repräsentativer Anforderungskatalog für ein verteiltes, transaktionales System abgeleitet. Dieser Anforderungskatalog wird anschließend mit dem \textit{Actor-Model} in einem praktischen Beispiel umgesetzt. Die daraus resultierenden praktischen Lösungsansätze, werden abschließend beschrieben sowie diskutiert.
 
\section{Abgrenzung}
Wie bereits erwähnt, erstreckt sich das Thema Actors sowie transaktionale und verteilten Systeme über ein großes und umfangreiches Wissensgebiet. Der Schwerpunkt dieser Arbeit liegt auf dem \textit{Actor-Model} und die Möglichkeit mit diesem Softwaremodel eine verteilte Anwendung zu realisieren. Auf stark verknüpfte Themen wie das \textit{Domain Driven Design} Konzept aus \cite{Evans2004Domain-drivenSoftware}, oder verschiedene Datenbanksystemen wird zwar eingegangen, sie werden aber nicht näher betrachtet. Verwandte Themengebiete für verteilte Systeme wie beispielsweise Container Infrastruktur, Netzwerktechnik oder Betriebsysteme werden im Zuge dieser Arbeit nicht di, da diese Themengebiete aufgrund der Infrastrukturellen Sicht, nicht direkt eine Rolle für die Beantwortung der Forschungsfrage spielen. 

\section{Aufbau}
Die Arbeitet unterteilt sich in zwei Teile. Beginnend mit dem theoretische ersten Teile, wird mit dem Kapitel \fullref{actor:chapter} () auf das \textit{Actor-Model} eingegangen und diskutiert. Nachfolgend folgt das Kapitel \fullref{cha:distributedSystems}, welches sich mit den Problemen beschäftigt welche bei verteilten Systemen häufig anzutreffen sind. Der theoretische Teil der Arbeit wird mit dem Kapitel \fullref{cha:cha:transactionSystems} abgeschlossen, welcher bekannte Lösungsansätze für transaktionale Systeme diskutiert. \\
Der zweite Teil der Arbeit umfasst die praktische Auseinandersetzung mit der Forschungsfrage. Dabei wird in Kapitel \fullref{cha:Eruierung} der Anforderungskatalog basierend auf den in Teil eins erarbeiteten Informationen erstellt, und vorhandene Frameworks für die Umsetzung betrachtet. Auf die Umsetzung des Anforderungskataloges wird anschließend in Kapitel \fullref{cha:practicalDevelopment} eingegangen. Abschließend wird in Kapitel \fullref{cha:evaluation} der erarbeite Erkenntnisstand diskutiert und Bewertet.  