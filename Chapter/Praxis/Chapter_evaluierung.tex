\chapter{Evaluierung} \label{cha:evaluation}
Das abschließende Evaluationskapitel beleuchtet die Implementierung des praktischen Anwendungskatalogs hinsichtlich der in Kapitel \ref{sec:Eruierung:technicalRequierements} geforderten Kriterien. Dazu wird zuerst ein Testlauf der \textit{TyrolSky} Anwendung besprochen und auf die Ergebnisse eingegangen. Darauf aufbauend wird im Anschluss die Forschungsfrage auf Basis des in den vorangegangenen Kapitel erworbenen Wissens besprochen. Abschließend folgt eine Diskussion sowie ein Ausblick auf die weitere Entwicklung des \textit{Actor-Models}. 
% * <feitzinger.magdalena@gmail.com> 2018-05-28T11:00:07.724Z:
% 
% > Darauf aufbauend wird im Anschluss die Forschungsfrage auf Basis des in den vorangegangenen Kapitel erworbenen Wissens besprochen.
% Die Forschungsfrage wird nicht besprochen, sie wird versucht zu beantworten. 
% 
% ^.

\section{TyrolSky-Testlauf}
Als Basis für die nachfolgende Bewertung dient der aufgebaute Testlauf. Für den Betrieb der \textit{Tyrol-Sky} Anwendung werden die verschiedenen Komponenten, in einem mittels \textit{Docker} simulierten Netzwerk, zusammengeschlossen. Die teilnehmenden Komponenten am Test können aus der Tabelle \ref{tab:evaluation:testStage} entnommen werden. \\
\begin{table}
    \centering
    \begin{tabular}{lc}
        Komponente       &   Anzahl  \\ \hline
        Lighthouse       &   2       \\
        API              &   1       \\
        Query-Service    &   2       \\
        Command-Service \& Domain-Service  &   3       \\
        Bank APU         &   1       \\
        Testanwendung    &   1
    \end{tabular}
    \caption{Verwendete Komponenten und deren Anzahl während eines Testlauf.}
    \label{tab:evaluation:testStage}
\end{table}
Nachdem alle Komponenten gestartet und miteinander verbunden sind, werden die Testdaten, aus Kapitel \ref{sec:eruierung:testdata}, in die Anwendung eingespielt. Die Einspielung erfolgt über die verfügbare Schnittstelle von der bereits gestarteten Komponente \textit{API}. Vor jedem Testlauf wird die gesamte Anwendung neugestartet und der Datenstand auf den Ursprungswert gesetzt. \\

\subsection{Beschreibung eines Testlaufes}
Innerhalb eines Testlaufes wird über die Testapplikation das \textit{TyroSky}-System mit einer Vielzahl an gleichzeitigen Buchungsanfragen unter Last gesetzt. Dabei werden die verfügbaren Flüge von der Testanwendung gebucht. Als Testparameter werden {2000} Ticketbuchungen auf allen verfügbaren Flügen innerhalb des Zeitraums 1. Juni bis 1. Juli gestartet. \\

\subsection{1. Testlauf}
Der erste Testlauf findet ohne Einflüsse von außen statt. Es werden daher während des Testes keine Komponenten entfernt oder hinzugefügt. Ist der Testlauf beendet, wird der Status der einzelnen Testbuchungen über die Datenbanktabelle überprüft. Anschließend werden die Kontobewegungen der simulierten Bankenanwendung mit den durchgeführten Buchungen verglichen. Dabei sollte für jede erfolgreiche Buchung eine verbuchte Kontobewegung gefunden werden. Abschließend wird stichprobenartig die Passagierliste für die gebuchten Flüge überprüft. Auch diese sollten mit den in der Testanwendung gebuchten Tickets übereinstimmen. \\

\subsection{2. Testlauf}
Im zweiten Testlauf wird der Ausfall einer \textit{Domain-Service} Komponente simuliert.  Im laufenden Betrieb wird diese Komponente unkontrolliert beendet. Das sollte dazu führen, dass Buchungen, welche von dieser Komponente bearbeitet werden, nicht in einem Fehlerzustand hängen bleiben, sondern vielmehr von einer der verbleibenden \textit{Domain-Services} übernommen werden. 

\subsection{3. Testlauf}
Um die in Kapitel \ref{sec:Eruierung:technicalRequierements} geforderte Skalierung der Anwendung zu repräsentieren, wird in diesem Testlauf während den Buchungsvorgängen eine weitere  \textit{Domain-Services} Komponente zum System hinzugefügt. Die neue Komponente soll Teile der bereits vorhandenen Buchungsprozesse übernehmen. Nach Beendigung des Testlaufs soll auch hier wieder alle Buchungen, wie im ersten Testlauf beschrieben, erfolgreich abgeschlossen sein. 

\subsection{Ergebnisse}
\label{subsec:evaluation:resultsTestRuns}
Nach jedem Testlauf wurden eine Überprüfungen der Buchungsresultate, Kontobewegungen sowie die Kontrolle der Passagierlisten durchgeführt. Somit kann gezeigt werden, dass die Anwendung die Transaktionalen Daten in einem verteilten Umgebung korrekt verarbeitet und dabei keine Inkonsistenzen in den Daten auftreten. Die Ergebnisse des Datenvergleichs ist der Tabelle \ref{tab:evaluation:resultsTestRuns} zu entnehmen. Demnach konnte für jedes gebuchte Ticket auch eine entsprechende Abbuchung auf der Bankenanwendung gefunden werden. Die abgebrochenen Buchungsanfragen lassen sich damit erklären, dass die Bankenanwendung die Buchungen abgelehnt hat. Es wurden beim zweiten Testlauf während der simulierten Störung einige Anfragen abgebrochen, jedoch entstand dabei keine Dateninkonsistenz.
\begin{table}
    \centering
    \begin{tabular}{p{1.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm}}
        Testlauf    & Testbuchungen       &   Abgeschlossene Tickets & Abgebrochene Buchungen & Abgebuchte Flüge  \\ \hline
            1.      & 2000                &         1827             &      173               &         1827        \\
            2.      & 2000                &         1820             &      180               &         1820        \\
            3.      & 2000                &         1852             &      148               &         1852        
    \end{tabular}
    \caption{Ergebnisse der drei Testläufe.}
    \label{tab:evaluation:resultsTestRuns}
\end{table}

\section{Bewertung der Umsetzung}
\label{cha:rating}
Die Bewertung des praktischen Umsetzungsbeispiels, erfolgt zuerst durch ein Vergleich der technischen- sowie der Prozessanforderungen aus Kapitel \ref{sec:Eruierung:technicalRequierements} mit der umgesetzten Implementierung. Anschließend wird die Bewertung mit einer Diskussion, welche die im ersten Abschnitt besprochenen theoretischen Inhalte mit der praktischen Umsetzung bespricht, weitergeführt. Bekannte Probleme der vorliegenden Implementierung sowie Probleme während der realisierung der Anwendung komplementieren die Bewertung.

\subsection{Anforderungsvergleich}
Der Anforderungskatalog aus Kapitel \ref{sec:Eruierung:technicalRequierements} fordert sechs unterschiedliche Anforderungen an die Implementierung der Anwendung. Davon konnten insgesamt fünf erfüllt werden und eine Anforderung wurde zum teil erfüllt. \\
Nachfolgend eine Übersicht über die Erfüllung der einzelnen Anforderungen.
\begin{enumerate}
    \litem{Verteilbare Komponenten} 
    Die Verteilbarkeit der einzelnen Komponenten ist durch den einsatz des \textit{Gossip}-Protokolls möglich. Weiters ermöglicht der Einsatz von Routern, wie in Kapitel \ref{subsec:implementation:akkaRouting} beschrieben, eine einfache Kommunikation  zwischen den verteilen Komponenten. Die fünf unterschiedlichen Komponententypen sind voneinander nicht Abhängig, bilden zusammengeschlossen aber eine homogene Anwendung.

    \litem{Automatische Skalierung}
    Die Skalierung der Anwendung ist durch das hinzufügen sowie entfernen von Komponenten möglich. Dabei organisieren sich die im System gehaltenen Daten durch \textit{Sharding} bei einer Änderung der Clusterstruktur selbständig neu. Benutzeranfragen werden durch die verwendung von Routern automatisch an die verfügbaren Komponenten verteilt und eine horizontale Skalierung ist somit möglich. Um eine anpassung an der Anzahl an Komponenten vorzunehmen, ist jedoch in der vorliegenden Implementierung ein manueller Schritt möglich. Komponenten hinzufügen oder ändern ist nur möglich in dem die Entsprechende Instanz manuel gestartet bzw. beendet wird. Jedoch sind keine weiteren manuellen Schritte notwendig damit die Komponente mit dem vorhandenen System interagiert. 

    \litem{Verteilte sowie Transaktionale Daten}
    Der Umgang mit verteilten Daten war bei den Designentscheidungen für die \text{TyrolSky}-Anwendung einer der Hauptmerkmale. Die in Abschnitt \ref{subsec:implementation:domainService} beschriebenen Daten für Fluginformationen oder Ticketbuchungen werden durch \textit{Sharding} verteilt. Durch die Implementierung von \textit{EventSourcing} ist auch die Persistierung der verteilten Daten sichergestellt. Das zusammenspiel der synchronen Nachrichtenabarbeitung des \textit{Actor-Models} sowie des \textit{Shardingalgorithmus} ermöglicht die sicherstellung der Datenkonsistenz über die gesamte verteilte Anwendung.
   
    \litem{Fehler sowie Netzwerk-Partition beständig}
    Bei einem Ausfall der Komponente wird dieser Zustand durch das \textit{Gossip}-Protokoll an alle teilnehmenden Komponenten propagiert. Dadurch ist eine Isolierung von fehlerhaften Clusterteilnehmer möglich. Durch die Möglichkeiten der \textit{Supervision} des \textit{Actor-Models}, ist auch die Lösung von Fehlern innerhalb einer Komponente einfach möglich. \\
    Der Umgang mit einer möglichen Separierung des Netzwerkes wird erfolgt mit dem in Abschnitt \ref{subsec:implementation:splitBrain} beschriebenen \textit{Split Brain Resolver}. Fehler in der Anwendung führen somit nicht zum totalausfall des gesamten Clusters, im schlimmsten Fall ist ein Ausfall einer Komponentengruppe möglich.
\end{enumerate}
Die im Anforderungskatalog gestellten Bedingungen konnten somit erfüllt werden. Die Möglichkeit der vollautomatischen Skalierung der Anwendung ist zwar nicht gegeben, jedoch war dieser Punkt für die Beantwortung der Forschungsfrage nicht erforderlich. Vielmehr konnte bei der implementierten Skalierung gezeigt werden, dass das hinzufügen und entfernen von Komponenten einfach möglich ist ohne dabei die laufende Applikation negativ zu beinflusen. 

\subsection{Implementierungs Diskussion}
Wie die Tests aus Abschnitt \ref{subsec:evaluation:resultsTestRuns} zeigen kann die Implementierung der \textit{TyrolSky}-Anwendung mit den vorgegebenen Anforderungen ausreichend umgehen. Die Umsetzung mit unterschiedlichen Komponenten hat den Vorteil, das die Anwendung von Grund auf in die verschiedene Anforderungskategorien aufgeteilt ist. Diese Aufteilung ermöglicht es, die unterschiedlichen Herausforderungen zu separieren. Der Quellcode der \textit{API}-Komponente zeigt Beispielhaft die Trennung der Aufgaben der einzelnen Komponente. Diese Komponente beinhaltet selbst keinerlei Geschäftslogik sondern fokussiert sich auf die abhandlung von \textit{HTTP} Anfragen, die restliche Arbeit wird an eine andere Komponente abgegeben. Durch diese Entkopplung der verschiedenen Herausforderungen konnte ein wichtige Grundlage für die Verteilbarkeit der gesamten Anwendung erreicht werden. \\
Ein anderer wesentliches Detail der Implementierung ist die Verwendung von \textit{Event-Sourcing} für die Datenhaltung. Dadurch kann die Auslastung der verwendeten Datenbank, vor allem was den Lesezugriff betrifft, im Vergleich zur gebräuchlichen \textit{CRUD}-Operationen reduziert werden. 
\graffito{\textit{CRUD} steht für \textit{Create, Read, Update, Delete} und beschreibt den Zugriff auf die Datenbank für jede Operation an ein Datenhaltendes System. \citep{martin1981managing}}
Eine Datenbank ist zwar für eine dauerhafte Speicherung der Daten notwendig, durch die Fehlende Struktur der in der Datenbank gespeicherten Daten, ist aber auch die Verteilung dieser einfach möglich. Die vorliegende Umsetzung verwendet zwar eine Relationale Datenbank, jedoch ist der Umstieg auf eine \textit{NoSQL} Datenbank ohne Aufwand möglich. \\
Die Prinzipien des \textit{Reactive Manifesto} aus Kapitel \ref{reactiveManifesto} wurden so weit wie möglich eingehalten. Einerseits ist die Nachrichtenorientiert durch die strikte Verwendung von Actors sowie Events implizit gegeben. Weiters ist die Elastizität sowie die Antwortbereitschaft durch die bereits beschriebene Komponenteorientierung gegeben. Für eine korrekte Erfüllung des \textit{Manifesto} ist jedoch noch eine vollautomatische Skalierung der Anwendung erforderlich. \\
Die in Kapitel \ref{sec:distributedSystems:capTheorem} behandelte Problematik des \text{CAP}-Theorem wurde durch den Verzicht auf vollständige Partitions Toleranz gelöst. Die Anwendung versucht mittels der in Abschnitt 
\ref{subsec:implementation:splitBrain} beschriebenen Methoden Netzwerkpatitionen zu erkennen und diese Anschließend aus dem Cluster zu entfernen. Dadurch ist die Anwendung in dem partitionierten Netzwerk nicht mehr erreichbar. Der Umgang mit transaktionalen Daten durch den \textit{Sharding}-Mechanismus ermöglicht der Anwendung eine einfache und Fehlerresistente Verteilung von Datensätzen, wobei die Hürden des \textit{CAP}-Theorems beachtet werden.


\subsection{Vorhandene Probleme der Umsetzung}
Neben der Erfüllung der Anforderungen sind auch einige Probleme mit der verwendeten Architektur, sowie der Implementierung bekannt. Dies betrifft in erster Linie die Implementierung des \textit{Query}-Services. Durch die Überwachung der aufgetretenen Events über die \textit{Event-Sourcing} Datenbank, ist jeder einzelne Abfragetyp aufwändig zu Implementieren und die Aufbereitung der Abfragen kann bei einer vielzahl an parallel Aufgetretenen Events einige Zeit in anspruch nehmen. Weiters ist ein Fehler bei der Implementierung des in Kapitel \ref{subsubsub:implementation:queryActorModel:resultPreparator} beschriebenen Globalen Namensservice. Dieser vergibt bereits vergebene Identifikationen unter bestimmten umständen nochmals. Dies passiert vorallem wenn sich eine Komponente nicht korrekt vom System abmeldet. \\
Eine weitere bekannte Schwäche der Implementierung betrifft die Testanwendung. Durch die Verwendung einer relationalen Datenbank für die Protokollierung der Testanwendung ist ein \textit{SQL} basierter Zugriff notwendig. Dabei kommt es mit der gewählten Implementierungsart zu Problemen wenn viele Zugriffe auf die Datenbank parallel ausgeführt werden. Dieses Problem wurde zwar bereits durch den einsatz eines lokalen Routers, welche die gleichzeitigen Datenbankzugriffe limitiert, minimiert. Jedoch kommt es weiterhin bei einer hohen Anzahl an Tests zu Problemen beim Datenbankzugriff. 

\chapter{Fazit}
\section{Auseinandersetzung mit der Forschungsfrage}
% Wie lässt sich eine Softwarearchitektur für ein verteiltesTransaktionssystem mit der Hilfe des Actor-Models realisieren? Welche Pro-bleme entstehen dabei und wie sehen Lösungsansätze dafür aus?
Mit der in Kapitel \ref{cha:practicalDevelopment} umgesetzten Anwendung konnte ein wesentlicher Teil der Forschungsfrage \ref{theorem:forschungsfrage} bereits behandelt werden. Mit den in \cite{Vernon2015ReactiveAkka} und \cite{akkaInAction} diskutierten Architekturmustern lässt sich ein auf dem Actor Model beruhendes verteiltes System erstellen welches mit Transaktionalen Daten umgehen kann. Eine Serviceorientierte Architektur hilft dabei die gesamte Anwendung verteilbar zu gestalten. 
Das einbeziehen des in \cite{gilbertPerspectiveCAPTheorem2012} besprochene \textit{CAP-Theorem} hilft bei der Entwerfung der Softwarearchitektur und vermeidet von vornherein Probleme mit der Verteilung der Anwendung. \\
Die Verwendung von Frameworks für die Anwendung des Actor-Models, siehe dazu Abschnitt \ref{sec:ActorFrameworks}, unterstützt die Entwicklung einer Anwendung in vielen Punkten. Unter anderem sind viele Architekturmuster bereits in den unterschiedlichen Frameworks vorgegeben. Weiters ist die die Unterstützung der entsprechenden Communities rundum die Frameworks hilfreich beim Lösen von Problemen. \\
Ein Hauptproblem welches bei der Bearbeitung der Forschungsfrage aufgetreten ist, betrifft die Verteilung von Daten über mehrere Rechner. Im Zuge der aufbereitung der theoretischen Grundlagen im ersten Teil dieser Arbeit, konnte dafür das Konzept von \textit{Shards} sowie \textit{Event-Sourcing} für die Lösung dieses Problems gefunden werden. Die praktische Umsetzung der Beispielanwendung konnte zeigen, das diese Konzepte für die Implementierung eines verteilten Transaktionssystems Zielführend sind. \\
Die Implementierung einer Softwarearchitektur mit dem \textit{Actor-Model} ist zu beginn Aufwendig, da das Programmiermodel im Gegensatz zum weit verbreiteten Objektorierten-Model abweicht. Deshalb müsste in einem Team welches die vorgeschlagene Architektur umsetzt zuerst entsprechendes Grundwissen über das \textit{Actor-Model} erarbeitet werden. \\


\section{Weiterführende Diskussionen und Forschungsausblick}
Die Bedürfnisse von Unternehmen für verteilte Systeme steigt ständig an. So ist unter anderem laut \cite{theSkillsCompaniesNeedMost} die meist Nachgefragte Qualifikation von Unternehmen das Verständnis über verteilte Cloud-Systeme. Mit der in dieser Arbeit umgesetzten Lösung lässt sich ein solch gefordertes verteiltes System umsetzen. \\
keine ahnung was noch