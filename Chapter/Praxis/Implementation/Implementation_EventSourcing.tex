\section{Implementierung von Event Sourcing}
\label{sec:implementation:eventSouring}
Wie bereits erwähnt, basiert die Persistierung der Daten auf dem, im Abschnitt \ref{sec:eventSourcing} beschriebenen, \textit{Event Sourcing}. Das Prinzip von \textit{Event Sourcing} ist es, aufgetretene Ereignisse abzuspeichern und gegebenenfalls wieder einzuspielen um so einen Zustand reproduzieren und nachvollziehen zu können \citep{betts2013CQRSEventSourcing}. \\
Das verwendete Framework \textit{Akka.net}, bietet eine grundlegende Unterstützung für \textit{Event Sourcing} \citep{Akka.netCommunityAkka.NETDocumentation}. Dabei werden Events als Nachrichten repräsentiert, welche dem Framework übergeben und anschließend abgespeichert werden. Nach erfolgreicher Speicherung des Events, kann auf das aufgetretene Event reagiert werden. Weiters bietet \textit{Akka.Net} die Möglichkeit, Events zu einem späteren Zeitpunkt wieder einzuspielen und mit einer anderen Verhalten darauf zu reagieren als wie beim eigentlichen auftretten des Events. Dies ist erforderlich, damit Ereignisse welche in der Vergangenheit aufgetreten sind, zwar wieder eingespielt werden können. Dabei wird die Einspielung eines Events meist nicht gleicht behandelt, als wie wenn das Ereignisse gerade aufgetreten ist. Wird beispielsweise bei einer Ticketbuchung das Bankkonto belastet, und wird die Buchung nachträglich wieder eingespielt, sollte zwar der Status des Tickets aktualisiert werden, eine neuerliche Kontobelastung ist aber nicht mehr erforderlich. Deshalb werden in diesem Beispiel zwei verhalten für das gleiche Ereignis benötigt.

\subsection{Aggregate Root}
Um die Implementierung der einzelnen Entitäten zu vereinfachen, wurde die Logik für \textit{Event Sourcing} in einer Basisklasse zusammengeführt, von welcher die eigentlichen Entitäts-Actoren ableiten. 
Die Basisklasse bietet die Methode \textit{Emit(IDomainEvent e, Action a)} an, welche die eigentliche Logik für die Speicherung des Events übernimmt. Der Verwender der Methode \textit{Emit()} übergibt dieser ein Event, welche alle Informationen über das aufgetretene Ereignis enthält. Weiters wird eine Action übergeben, welche ausgeführt wird, sobald das Event erfolgreich im \textit{Event Store} abgelegt wurde. Während der Speicherung des Events wird von \textit{Akka.net} sichergestellt, dass keine weiteren Nachrichten vom Actor abgearbeitet werden. Die Methode \textit{Emit()} speichert jedoch nicht nur das Event im \textit{Event Store} ab. Bevor es nach der Speicherung des Events die übergebene Action ausführt, wird die abstrakte Methode \textit{UpdateState()} aufgerufen. \\
Jede Ausprägung der abstrakten \textit{Aggregate Root} Klasse muss die Methode \textit{UpdateState(IDomainEvent e)} implementieren. Diese wird, wie bereits erwähnt, direkt nach der erfolgreichen Persistierung des Events von der Methode \textit{Emit()} aufgerufen. Die Implementierung der Methode \textit{UpdateState()} sollte den Zustand des Actors, entsprechend dem aufgetretenen Event, verändern. Im Gegensatz zu der zuvor übergebenen \textit{Action}, wird \textit{UpdateState()} auch bei einer historischen Einspielung der Events aufgerufen. Die Methode \textit{UpdateState()} sollte mit allen unterschiedlichen Event Varianten, welche innerhalb des Actors auftretten können, umgehen können und dementsprechend die interne Repräsentation des Actors verändern. Das führt dazu, dass Änderungen des internen Zustands des Actors, ausserhalb der Methode \textit{UpdateState()}, bei einer wiedereinspielung der Ereignisse zu unterschiedlichen Zuständen des Actors führen kann. Deshalb sollten sämtliche Änderungen des Zustands des Actors innerhalb der Methode \textit{UpdateState()} ausgeführt werden. \\
Nach dem aktualisieren des Actors-State prüft die Methode ob ein \textit{Snapshot} ausgeführt werden soll, siehe dazu den folgenden Abschnitt \ref{subsec:implementation:eventSouring:Snapshot}. Abschließend wird die zuvor übergebene Methode \textit{Action} aufgerufen, welche die eigentliche Logik enthält wie auf das aufgetretene Ereignis reagiert wird. Unter anderem können hier andere Actors über das aufgetretene Ereignis benachrichtigt werden. Die Action wird nur aufgerufen wenn das Event tatsächlich auftritt, bei einer wiedereinspielung des Events wird ausschließlich die Methode \textit{UpdateState} aufgerufen.  \\
In der Abbildung \ref{fig:implementation:eventSourcingAggregateRoot} ist der beschriebene Prozess schematisch abgebildet. Daraus ist auch zu entnehmen, das zwei unterschiedliche Datenbanken verwendet werden um Snapshots und Events abzubilden.
\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{gfx/implementation/EventSourcingAkka}
    \caption{Ablauf der Speicherung eines Events innerhalb eines \textit{Aggregate Root} Actors mit \textit{Event Sourcing} und \textit{Snapshots}.}
    \label{fig:implementation:eventSourcingAggregateRoot}
\end{figure} 

\subsection{Snapshot}
\label{subsec:implementation:eventSouring:Snapshot}
Um bei einer Wiedereinspielung der Ereignisse für einen Actor nicht alle bereits aufgetretenen Ereignisse  wieder einspielen zu müssen, und dabei für jedes Ereignis die Methode \textit{UpdateState()} aufrufen zu müssen, wird regelmäßig ein Abbild des aktuellen Actorzustands gespeichert. Dies passiert innerhalb der Methode \textit{Emit()}. In der vorliegenden Implementierung wird nach jedem zwanzigsten Event ein Snapshot erstellt. Dafür wird die interne Datenrepräsentation eines Actors in eine eigene serialisierbare Klasse, den \textit{Actor State}, abgebildet. Diese Klasse wird auch bei der oben besprochenen Methode \textit{UpdateState()} verändert. Wird nun ein Snapshot erstellt, so wird der aktuelle \textit{Actor State} in einer dafür vorgesehenen Datenbank abgespeichert. Zusätzlich zum aktuellen \textit{State} wird die Sequenznummer des letzten Events, welches zu diesem \textit{State} geführt hat, gespeichert. Während der Erstellung des Snapshots, kann der Actor selbst jedoch weiterhin Nachrichten abarbeiten. Dies beeinträchtigt nicht die Konsistenz der Datenrepräsentation. Durch die Zuordnung von einer Sequenznummer zu einem abgespeicherten \textit{State}, werden Events welche während der erstellung des Snapshots anfallen, nicht mehr zum Snapshot dazu gezählt und somit später wieder auf Basis des vorhandenen Snapshots eingespielt. \\
Wird nun ein gestoppter Actor, dessen Zustand mittels \textit{Event Sourcing} persistiert wurde, wieder gestartet, so wird der vorherige Zustand wieder hergestellt. Während vergangene Ereignisse eingespielt werden, kann der Actor keine neuen Nachrichten verarbeiten. Diese verbleiben solange in der Mailbox des Actors, bis die Einspielung abgeschlossen ist. \\
Die Wiederherstellung eines Actors wird dadurch erreicht, in dem zuerst der Zuletzt verfügbare \textit{Snapshot} für den Actor in der Datenbank gesucht wird. Anschließend wird der Zustand des entsprechenden \textit{Snapshots} dem Actor als \textit{State} zugeteilt. Nun werden alle Events, welche nach der Erstellung des Snapshots angefallen sind, in der zeitlichen Reihenfolge deren auftretten, wieder in den Actor eingespielt. Nach dem letzten eingespielten Event, ist der Zustand des Actors exakt der gleiche wie vor dem stoppen des Actors.

\subsubsection{Actors mit \textit{Event Sourcing}}
Wie bereits angedeutet, sind nicht alle Actors innerhalb der \textit{TyrolSky}-Anwendung unter \textit{Event Sourcing}. Nur Actors welche einen Zustand repräsentieren welcher für die Konsistenz der Anwendung notwending ist, wurden mit \textit{Event Sourcing} persistiert. Dies sind folgende Actors: 
\begin{itemize}
    \item{\textit{OperateFlight}}
    \item{\textit{FlightPassangerList}}
    \item{\textit{ChargingCoordinator}}
    \item{\textit{FlightTicket}}
    \item{\textit{FlightNumber}}
    \item{\textit{DistributedUniqueNamingService}}
\end{itemize}
Alle bis auf den Actor \textit{DistributedUniqueNamingService} sind Teil der Komponente \textit{Domain Service} und präsentieren die Domäne der \textit{TyrolSky}. Der verbleibende Actor \textit{DistributedUniqueNamingService} dient zur Implementierung der unterschiedlichen \textit{Query}-Aufbereiter des \textit{Query-Services}, welche bereits in Abschnitt \ref{subsubsub:implementation:queryActorModel:resultPreparator} beschrieben wurden.

\subsection{Version Problematik}
Durch die Möglichkeit bereits aufgetretene Events immer wieder dem Actor einzuspielen, muss sichergestellt werden, dass Events bei einer späteren Wiedereinspielung gleich behandelt werden, als zu dem Zeitpunk an welchem das Ereignis tatsächlich aufgetreten ist. Ändert sich die Implementierung für einen bestimmten Event-Typ innerhalb der Methode \textit{UpdateState()}, welche wie besprochen auch vergangene Events verarbeitet, kann es zu inkonsistenzen der Anwendung kommen. Deshalb muss bei einer anpassung von vorhandenem Code der \textit{UpdateState()} Methode, entschieden werden, ob dies Codeänderung auch für ältere Events zulässig ist. Denn wird durch die Codeanpassung nun für Events ein anderer Actor State als zuvor berechnet, kann nicht mehr der Originalzustand zum Zeitpunk des Ereignisses herbeigeführt werden. \\
Deshalb wird, sollte ein neues Verhalten für ein bereits vorhandenes Ereignis benötigt werden, ein neuer Event-Typ eingeführt. Durch die Versionierung von Event-Typen können keine inkonsistenzen durch Codeänderungen in das System gebracht werden. 

