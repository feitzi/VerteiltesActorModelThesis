\chapter{Transaktionssysteme} \label{cha:transactionSystems}
Die Verarbeitung von Informationen in einem Rechnernetzwerk stellt je nach Anwendungsfall verschiedenste Ansprüche an das verarbeitende System. Eine Transaktion selbst ist nach \cite{rahm1993HochleistungsTransaktionssysteme} eine Gruppe von zusammengehörenden Operationen welche gemeinsam das \textit{ACID} Prinzip, siehe Abschnitt \ref{sec:transactionTheory:acid}, einhalten und somit keine Datenanomalien oder Inkonsistenzen zulassen. \\
Durch den rapiden Anstieg an Anfragen an ein Transaktionssystem sowie die dadurch erfolgte Verteilung der Systeme, wie in \cite{li2017research} beschrieben, haben sich die Ansprüche an Transaktionssysteme in den letzten Jahren verändert. Die Verteilung von Datenverarbeitenden und Persistierenden Systemen führt zu neuen Herausforderungen, nicht zuletzt wegen dem \textit{CAP-Theorem}, siehe Kapitel \ref{sec:distributedSystems:capTheorem}, welche in diesem Kapitel diskutiert werden. 

\section{Transaktionskonzepte}
Ein Transaktionssystem muss nach \cite{rahm1993HochleistungsTransaktionssysteme} einem definierten Konzept folgen und dieses jederzeit garantieren können, um so Transaktionen zu verarbeiten. Dabei haben sich zwei grundlegende Konzepte, \textit{ACID} und \textit{BASE}, entwickelt, auf welche nachfolgend eingegangen wird. Welches der beiden Konzepte sich in der Praxis besser verwendet lässt, hängt vom Anwendungsfall ab. Laut \cite{EdlichFriedlandHampeBrauer201010}
% * <feitzinger.magdalena@gmail.com> 2018-03-07T09:10:25.436Z:
% 
% > ederzeit garantieren können, u
%  was muss garantiert werden können? 
% 
% 
% ^.
unterscheidet sich die Ziele dieser zwei Konzepte grundsätzlich, weshalb sie sich zum Teil nur schwer vergleichen lassen.  \textit{ACID} ist mehr auf das Garantieren der Konsistenz hin optimiert, während \textit{BASE} die Verteilung der Anwendung priorisiert.

\subsection{ACID}\label{sec:transactionTheory:acid}
Der Begriff \textit{ACID} steht für die vier Eigenschaften \textit{Atomarität}, \textit{Konsistenz}, \textit{Isolation} und \textit{Dauerhaftigkeit}. Ein \textit{ACID} basierendes System gilt als restriktives Transaktionssystem welches durch die, vor und nach einer Transaktion,  immer geltenden Bedingungen von allen vier Eigenschaften nur äußert schwer verteil- und skalierbar ist- \cite{PritchettBASE}\\
Ein System welches \textit{ACID} erfühlt, bietet laut \cite{haerder198Acid} für eine Transaktion immer folgende vier Eigenschaften.
% * <feitzinger.magdalena@gmail.com> 2018-03-07T09:16:24.180Z:
% 
% > Ein System welches \textit{ACID} erfühlt, bietet laut \cite{haerder198Acid} für eine Transaktion immer folgende vier Eigenschaften.
% umformulieren. die eigenschaften ergeben sich aus dem wort ACID. 
% 
% ^.

\begin{description}
    \item[Atomarität] Alle Operationen welche sich innerhalb einer Transaktion befinden, werden atomar ausgeführt. Das bedeutet, es wird entweder alles ausgeführt oder gar nichts. Um das zu ermöglichen, muss das Transaktionssystem gewährleisten können, dass bei einem Rollback der Transaktion bereits ausgeführte Operationen auch wieder zurückgesetzt werden können. 
    \item[Konsistenz] Bei Beendigung einer Transaktion ist sichergestellt, dass sich die Datenbank in einem konsistenten Zustand befindet. Auch wird eine Transaktion nur erfolgreich abgeschlossen wenn alle Integrationsbedingungen des darunterliegenden Datenschemas erfühlt sind. 
    \item[Isolation] Eine gerade in Ausführung befindliche Transaktion wird von einer anderen Transaktion nicht beeinflusst. Die Isolation der Transaktion bewirkt, dass sich jede Transaktion so verhalten kann, als wäre sie die einzige im gesamten System.
    \item[Dauerhaftigkeit] Wird eine Transaktion erfolgreich abgeschlossen, muss vom Transaktionssystem garantiert werden können, dass sich die Daten der Transaktion dauerhaft im System befinden. Durch diese Eigenschaft kann sich der Ersteller der Transaktion, im Falle das diese erfolgreich abgeschlossen wird, darauf verlassen, dass die Daten im System enthalten sind.
\end{description}
Um diese vier Eigenschaften auch in einem verteilten System zu garantieren, ist laut \cite{PritchettBASE} ein zwei Phasen Commit erforderlich. In diesem werden in einer erster Commit Phase alle beteiligten Komponenten gefragt ob sie die Änderungen durchführen können. Wird dies von allen bestätigt, beginnt die zweite Phase. Hier werden der Commit dann von allen Beteiligten tatsächlich ausgeführt. Durch die Gewährleistung von Konsistenz über alle beteiligten Rechner ist demnach die Verfügbarkeit nach \textit{CAP} nicht garantiert und je nach Grad der Skalierung wird diese auch verringert.

\subsection{BASE}\label{sec:transactionTheory:base}
Ist jedoch die Verfügbarkeit in einem speziellen Anwendungsfall wichtiger als die jederzeit gültige Konsistenz, wie in \textit{ACID}, so muss eine anderes Transaktionskonzept verwendet werden. Das in \cite{PritchettBASE} beschriebene Konzept \textit{BASE} tauscht Verfügbarkeit durch Konsistenz indem es Konsistenz hinter der Verfügbarkeit einordnet. \\
\textit{BASE} steht für \textit{basically available, soft state, eventually consistent} und garantiert keine Konsistenz, versucht diese jedoch so gut wie möglich einzuhalten. Das wird durch die so genannte eventuelle Konsistenz erreicht. Demnach befindet sich ein System nicht immer in einem konsistenten Zustand, jedoch versucht es diesen Zustand mit Abgleich von anderen Komponenten zu erreichen. Dadurch kann der Durchsatz einer Anwendung erhöht werden. Die Konsistenz der Daten bezieht sich jedoch bei \textit{BASE} ausschließlich auf die Korrektheit der Daten und nicht, wie bei \textit{ACID}, auch auf die Integrität dieser \citep{EdlichFriedlandHampeBrauer201010}. Weiters bewirkt \textit{BASE} auch durch die Implementierung eines \textit{Soft State} das geschriebene Daten nicht direkt auf allen beteiligten Komponenten verfügbar sind. Diese werden nach und nach auf die beteiligten Rechner gespielt, was wiederum zu Erhöhung der Erreichbarkeit führt, da auf ein zwei Phasen Protokoll verzichtet werden kann \citep{EdlichFriedlandHampeBrauer201010}.

\section{Event Sourcing}
Bei gängigen Implementierungen verschiedenster Datenbanksystemen wird meist immer der aktuelle Zustand eines Tupels in der Datenbank gespeichert. Das führt dazu, dass bei Abfragen an das System der aktuelle Wert aus der Datenbank ausgelesen werden muss. Einen gänzlich anderen Ansatz wird beim \textit{Event Sourcing}, wie in \cite{vernon2013implementing} beschrieben, verwendet. Anstatt die Änderung an einem Datensatz direkt am Datensatz selbst vorzunehmen, wird beim \textit{Event Sourcing} nur das Event selbst, welches zu der Änderung führt, abgespeichert. Der Zustand des betroffenen Datensatzes selbst wird von der Datenbank nicht gehalten. Das Event selbst beschreibt was exakt vorgefallen ist. Wird so der Name einer Person verändert, wird das Event \textit{NameChanged} mit dem neuen Namen und eine Identifikation der betroffenen Person abgespeichert. Den aktuellen Zustand einer Identität wird jedoch nicht mehr von der Datenbank verwaltet sondern von der Applikation selbst. Durch das Einspielen von allen bereits geschehenen Events, in der gleichen Reihenfolge wie sie aufgetreten sind, kann der aktuelle Zustand jederzeit wieder hergestellt werden. Weiters ergibt sich durch das Persistieren von allen Events eine lückenlose Aufzeichnung wie der aktuelle Systemstatus zustande gekommen ist. 
Jedoch ist das Einspielen von Events, ab einer gewiesen Anzahl an Events, ressourcen- und zeitintensiv. In \cite{vernon2013implementing} wird deshalb empfohlen sogenannte Snapshots  anzulegen. Dabei wird immer wieder eine Zusammenfassung aller bisher Events erstellt und diese Aggregation an Eventdaten gespeichert.  Alle Einspielungen danach können aufgrund dieses Snapshot durchgeführt werden. Wie oft diese Snapshots erstellt werden kommt auf den Anwendungsfall an. Meist wird jedoch nach Eintreten einer bestimmten Anzahl an Events ein Snapshot erstellt. \\
In einem  \textit{Event Sourcing} Systems sind aufgetretene Events unveränderbar. Sind Fehler in Events passiert oder müssen rückgängig gemacht werden, so wird ein neues Event eingefügt welches das fehlerhafte Event wieder neutralisiert. Jedoch sind technisch diese Events vorhanden, sie werden jedoch durch neue ,inverse Events  neutralisiert \citep{vernon2013implementing}. 
% * <feitzinger.magdalena@gmail.com> 2018-03-07T09:34:12.854Z:
% 
% > Jedoch sind technisch diese Events vorhanden, sie werden jedoch durch neue ,inverse Events  neutralisiert 
% Wortwiederholung. Satz unlogisch zu lesen
% 
% ^.
\subsection{Zusammenhang mit CQRS}
Laut \cite{vernon2013implementing} werden im Kontext von \textit{Event Sourcing} Instanzen oder Tupels als Aggregat bezeichnet. Diese Aggregate horchen auf  Events welche im gesamten System empfangen werden können und ändern dementsprechend ihren Zustand. Da eine Event-basierte Datenbank nicht dazu geeignet ist Daten abzufragen oder gar Verbindungen unter den Daten, sogenannte Joins, zu bilden, wird ein anderes Konzept benötigt. In \cite{vernon2013implementing} wird dafür das \textit{Command-Query-Responsibility-Segregation}, kurz \textit{CQRS}, im Zusammenhang mit \textit{Event Sourcing} empfohlen. \\
Bei \textit{CQRS} werden dabei, laut \cite{cqrsYoung2010}, Abfragen und  Befehle strikt voneinander getrennt. So kann ein Teil der Applikation sich darauf spezialisieren Befehle zu übernehmen und der andere Teil spezialisiert sich auf die möglichen Leseanfragen an das System. Im Zusammenhang mit \textit{Event Sourcing} horcht die Leseseite der \textit{CQRS} Komponente auf Events und kann somit seine Daten für zukünftige Lesezugriffe aktualisieren. Im Gegensatz dazu werden bei Befehlen an das System nur Events an die \textit{Event Sourcing} Komponente versendet. Diese speichert die Events und verteilt sie weiters wieder im gesamten System. In Abbildung \ref{fig:transactionTheory:eventSourcing:cqrs} ist eine vereinfachte Abbildung einer \textit{CQRS}-Architektur mit \textit{Event Sourcing} zu sehen. In der Abbildung ist dabei zu sehen, dass zwei \textit{Query Handler} auf Events horchen. Befehle werden von einem \textit{Command Handler} angenommen welcher weitere verschiedene Events in das System einfließen lässt. Tritt für ein \textit{Query Handler} ein relevantes Event auf, so aktualisiert der Handler seine eigenen zwischengespeicherten Resultate. Die Resultate können schließlich direkt bei Anfragen an den Handler zurückgegeben werden. Somit entfallen aufwendige Datenbankabfragen und Synchronisierungsmechanismen bei komplexen Abfragen. \\
% * <feitzinger.magdalena@gmail.com> 2018-03-07T09:39:12.981Z:
% 
% >  zu sehen. In der Abbildung ist dabei zu sehen, dass zwei \textit{Query Handler} auf Events horchen. 
% 
% Wortwiederholung. 
% 
% ^.
\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{gfx/other/eventSourcingCqrs}
    \caption{Schematische, vereinfachte Darstellung von \textit{CQRS} mit \textit{Event Sourcing}.}
    \label{fig:transactionTheory:eventSourcing:cqrs}
\end{figure}

\subsection{Transaktionen und Event Sourcing}
Wird in einer Anwendung keine Datenbank verwendet, welche Transaktionen ermöglichen, muss die Konsistenz der Daten durch die Anwendung selbst gewährleistet werden. Ein Konzept, welches in einer hoch verteilten und auf Skalierung optimierten Umgebung Transaktionen ermöglicht, wird in \cite{helland2007life} vorgestellt. Demnach werden zusammengehörende Daten zu einer Entität zusammengefasst. Die Entität, dessen Umfang an Daten nicht begrenzt ist, bilden einen atomaren Kern welcher in einer Transaktion verändert werden kann. Jedoch kann eine Transaktion nur exakt eine einzelne Entität verändern. Die Entität selbst muss sich innerhalb einer serialisierbaren Einheit befinden, sprich innerhalb eines Rechners. Entitäten können anderen Entitäten Änderungen über sogenannte Aktivitäten mitteilen. Das in \cite{helland2007life} beschriebenen Konzept einer Entität deckt sich mit dem Begriff Aggregat aus der \textit{Domain Drive} Sprache von \cite{Evans2004Domain-drivenSoftware}. Weiters lassen sich Aktivitäten in Nachrichten, oder Events beschreiben. \\
% * <feitzinger.magdalena@gmail.com> 2018-03-07T09:42:22.670Z:
%
% > Weiters lassen sich Aktivitäten in Nachrichten, oder Events beschreiben. \\
%
% ^.
Da sich pro Transaktion demnach nur eine einzelnes Aggregat verändern lässt, wird ein Konzept benötigt in welchem mehrere Entitäten innerhalb eines Prozesses verändert werden können. In \cite{betts2013CQRSEventSourcing} wird dafür ein \textit{Process Manager} verwendet. Dieser steuert, für einen Geschäftsprozess zusammengehörende, Transaktionen. Dabei werden aufeinander aufbauende Transaktionen nacheinander ausgeführt. Schlägt eine Transaktion fehl, so werden alle davor bereits abgeschlossen Transaktionen mit inversen Transaktionen wieder zurückgesetzt. \\
Damit der \textit{Process Manager} alle Transaktionen richtig durchführen kann, muss gewährleistet sein, dass die Nachrichten genau einmal zu den Aggregaten ankommen. Wie jedoch bereits in Kapitel \ref{sec:actor:patterns:guaranteedDelivery} beschrieben, ist dies nicht wirklich möglich. Wird jedoch gewährleistet, dass eine Nachricht mindestens einmal ankommt, so kann der \textit{Process Manager} die Transaktionen auch ordnungsgemäß durchführen. Hierfür ist es jedoch erforderlich, dass die versendeten Befehle idempotent sind \citep{betts2013CQRSEventSourcing}. Damit sind Befehle, die öfters beim Aggregat ankommen, möglich. \\
Laut \cite{betts2013CQRSEventSourcing} und \cite{vernon2013implementing} erfordert der Einsatz von \textit{Event Sourcing} zusammen mit  Transaktionen ein detailliertes und darauf angepasstes Modellierung der Aggregate. \textit{Process Manager} selber sind durch ihre Komplexität aufwendig zu implementieren, jedoch ist durch diese Vorgehensweise ein hoher Grad an Skalierung und Verteilung möglich. \cite{helland2007life}